<?php
/**
 * @file abt.module
 * Module for controling access by using user->term<-node relationship.
 */

define('ABT_NO_CONTROL', 0);
define('ABT_CONTROL_DEFAULT_RESTRICT', 1);
define('ABT_CONTROL_DEFAULT_ALLOW', 2);

use \Drupal\Core\Session\AccountInterface;
use \Drupal\node\NodeInterface;
use \Drupal\Core\Form\FormStateInterface;
use \Drupal\abt\AbtUtils;
use \Drupal\field\Entity\FieldConfig;
use \Drupal\Core\Render\Element;

/**
 * Implements hook_node_grants().
 */
function abt_node_grants(AccountInterface $account, $op) {
  $abt_grants = &drupal_static(__FUNCTION__, []);
  if (isset($abt_grants[$account->id()][$op])) {
    return $abt_grants[$account->id()][$op];
  }
  $grants = [];
  $full_account = \Drupal\user\Entity\User::load($account->id());
  $access_map = \Drupal::entityTypeManager()
    ->getStorage('field_config')
    ->loadByProperties(array('field_type' => 'entity_reference', 'entity_type' => 'node'));
  if (empty($access_map)) {
    return;
  }
  $cop = 'abt_enable_' . $op . '_control';
  foreach ($access_map as $field_id => $realm) {
    $abt_settings = $realm->getThirdPartySettings('abt');
    if (empty($abt_settings) || !$abt_settings[$cop] || empty($abt_settings['user_field'])) {
      continue;
    }
    // Get the terms for the ABT field on this user.
    $field_name = $abt_settings['user_field'];
    $field_data = $full_account->get($field_name)->filterEmptyItems()->getValue();
    if (!empty($field_data)) {
      $grants['abt_' . $field_name] = AbtUtils::taxonomyGetChildrenAll($field_data);
    }
    // Make sure that user has the bare minimum in order to see unrestricted nodes
    $grants['abt_'. $field_name][] = 0;
  }
  $abt_grants[$account->id()][$op] = $grants;
  return $grants;
}

/**
 * Implements hook_node_access_records().
 */
function abt_node_access_records(NodeInterface $node) {
  $grants = [];
  $access_map = \Drupal::entityTypeManager()
    ->getStorage('field_config')
    ->loadByProperties(array('field_type' => 'entity_reference', 'entity_type' => 'node', 'bundle' => $node->getType()));
  // If there are no ABT enabled fields or the node is unpublished,
  // don't create any node access records.
  if (empty($access_map) || !$node->isPublished()) {
    return;
  }
  /**
   * @var string $field_name
   * @var FieldConfig $realm
   */
  foreach ($access_map as $field_id => $realm) {
    if (!$abtmap = $realm->getThirdPartySettings('abt')) {
      continue;
    }
    $field_name = $realm->getName();
    $field_data = $node->get($field_name)->filterEmptyItems()->getValue();
    if (empty($field_data)) {
      $grants[] = AbtUtils::grantConstruct(
        'abt_'.$abtmap['user_field'],
        0,
        ($abtmap['abt_enable_view_control'] == ABT_CONTROL_DEFAULT_ALLOW ? 1 : 0),
        ($abtmap['abt_enable_update_control'] == ABT_CONTROL_DEFAULT_ALLOW ? 1 : 0),
        ($abtmap['abt_enable_delete_control'] == ABT_CONTROL_DEFAULT_ALLOW ? 1 : 0)
      );
    }
    else {
      $used_tids = [];
      for($i = 0; $i < count($field_data); $i++) {
        // node_access table does not allow duplicate nid-gid-realm combo (in our case it's nid-tid-fieldname).
        // Duplicate terms will probably never happen in normal usage but devel-generate module does this
        // when field cardinality is greater then 1 (there is a debate on wheather this is a bug or not).
        // Anyway, we adress it here and prevent duplicate terms trigger writing to the node_access table.
        if(isset($field_data[$i]['target_id'])) {
          if(!in_array($field_data[$i]['target_id'], $used_tids)) {
            $used_tids[] = $field_data[$i]['target_id'];
              $grants[] = AbtUtils::grantConstruct(
                'abt_'.$abtmap['user_field'],
                $field_data[$i]['target_id'],
                ($abtmap['abt_enable_view_control'] == ABT_CONTROL_DEFAULT_RESTRICT || $abtmap['abt_enable_view_control'] == ABT_CONTROL_DEFAULT_ALLOW ? 1 : 0),
                ($abtmap['abt_enable_update_control'] == ABT_CONTROL_DEFAULT_RESTRICT || $abtmap['abt_enable_update_control'] == ABT_CONTROL_DEFAULT_ALLOW ? 1 : 0),
                ($abtmap['abt_enable_delete_control'] == ABT_CONTROL_DEFAULT_RESTRICT || $abtmap['abt_enable_delete_control'] == ABT_CONTROL_DEFAULT_ALLOW ? 1 : 0)
              );
          }
        }
      }
    }
  }
  return $grants;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function abt_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Make sure we are dealing with a term reference
  /** @var FieldConfig $field */
  $field = $form_state->getFormObject()->getEntity();
  if ($field->getType() !== 'entity_reference' || $field->getSetting('target_type') !== 'taxonomy_term' ||
    $field->getTargetEntityTypeId() !== 'node') {
    return;
  }
  $form['third_party_settings']['abt'] = [
    '#tree' => TRUE,
    '#title' => t('Access By Term'),
    '#type' => 'fieldset',
  ];

  $existing_settings = $field->getThirdPartySettings('abt');
  // Build a list of term reference fields on the user to use.
  $options = [];
  $user_fields = \Drupal::entityTypeManager()
    ->getStorage('field_config')
    ->loadByProperties(array('field_type' => 'entity_reference', 'entity_type' => 'user'));
  /** @var FieldConfig $user_field */
  foreach ($user_fields as $user_field) {
    if ($user_field->getSetting('target_type')  !== 'taxonomy_term' ) {
      continue;
    }
    $field_name = $user_field->getName();
    $field_label = $user_field->getLabel();
    $options[$field_name] = $field_label . ' (' . $field_name . ')';
  }
  foreach(array('view', 'update', 'delete') as $op) {
    $setting_key = 'abt_enable_'.$op.'_control';
    $form['third_party_settings']['abt'][$setting_key] = [
      '#type' => 'select',
      '#title' => t('Control "@op" access with this field.', array('@op' => $op)),
      '#options' => array(
        ABT_NO_CONTROL => t('No'),
        ABT_CONTROL_DEFAULT_RESTRICT => t('Yes, restrict access even if node is not tagged.'),
        ABT_CONTROL_DEFAULT_ALLOW => t('Yes, but allow access if node is not tagged.')
      ),
    ];
  }

  $options = ['' => t('- Select -')] + $options;
  $form['third_party_settings']['abt']['user_field'] = [
    '#type' => 'select',
    '#title' => t('User Field'),
    '#description' => t('Field on the user entity to determine access.'),
    '#options' => $options,
  ];

  foreach (Element::children($form['third_party_settings']['abt']) as $form_field_name) {
    $form['third_party_settings']['abt'][$form_field_name]['#default_value'] = isset($existing_settings[$form_field_name]) ? $existing_settings[$form_field_name] : NULL;
  }

  $form['actions']['submit']['#validate'][] = 'abt_form_field_config_edit_form_validate';
  $form['actions']['submit']['#submit'][] = 'abt_form_field_config_edit_form_submit';
}

/**
 * Extra validate function for the field config form.
 */
function abt_form_field_config_edit_form_validate(&$form, FormStateInterface $form_state) {
  // Check if the user is using this as an abt field.
  $enabled = FALSE;
  $abt_settings = $form_state->getValue(['third_party_settings', 'abt']);
  foreach(['view', 'update', 'delete'] as $op) {
    $setting_key = 'abt_enable_'.$op.'_control';
    if ($abt_settings[$setting_key]) {
      $enabled = TRUE;
      break;
    }
  }
  if (!$enabled) {
    $form_state->setValue('abt_disabled', 1);
  }
  else {
    // Validate the a corresponding term reference field on the user has been selected.
    if (empty($abt_settings['user_field'])) {
      $form_state->setError($form['third_party_settings']['abt']['user_field'],
        t('You must select a field on the user entity to enable ABT.'));
      return FALSE;
    }
    // Validate the selected user field references the same vocabulary.
    $target_bundles = $form_state->getValue([
      'settings',
      'handler_settings',
      'target_bundles'
    ]);
    /** @var FieldConfig $user_field */
    $user_field = FieldConfig::loadByName('user', 'user', $abt_settings['user_field']);
    $user_field_settings = $user_field->getSetting('handler_settings');
    if (empty(array_intersect($target_bundles, $user_field_settings['target_bundles']))) {
      $form_state->setError($form['third_party_settings']['abt']['user_field'],
        t('User field @field does not reference this vocabulary.', array('@field' => $abt_settings['user_field'])));
      return FALSE;
    }
    // If the settings for the field have changed, set a flag to rebuild permissions.
    // This has to be done in validate because by the time submit handlers are called,
    // settings have already been saved.
    $field = $form_state->getFormObject()->getEntity();
    $original_field = FieldConfig::load($field->id());
    $existing_settings = $original_field->getThirdPartySettings('abt');
    if (empty($existing_settings)) {
      $form_state->setValue('abt_rebuild_access', 1);
    }
    else {
      foreach ($existing_settings as $setting_key => $setting) {
        if ($abt_settings[$setting_key] !== $setting) {
          $form_state->setValue('abt_rebuild_access', 1);
          break;
        }
      }
    }
  }
}

/**
 * Extra submit function for the field config form.
 */
function abt_form_field_config_edit_form_submit(&$form, FormStateInterface $form_state) {
  // If the flag has been set in abt_form_field_config_edit_form_validate(),
  // set node access needs rebuild.
  if ($form_state->getValue('abt_rebuild_access')) {
    node_access_needs_rebuild(1);
  }
  if ($form_state->getValue('abt_disabled')) {
    // If the field is disabled, remove its settings.
    $field_config = $form_state->getFormObject()->getEntity();
    foreach (Element::children($form['third_party_settings']['abt']) as $key) {
      $field_config->unsetThirdPartySetting('abt', $key);
    }
    $field_config->save();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function abt_form_field_config_delete_form_alter(&$form, FormStateInterface $form_state) {
  /** @var FieldConfig $field */
  $field = $form_state->getFormObject()->getEntity();
  if ($field->getType() !== 'entity_reference' || $field->getSetting('target_type') !== 'taxonomy_term') {
    return;
  }
  // For term reference field on users.
  $items = [];
  if ($field->getTargetEntityTypeId() == 'user') {
    // See if there are any ABT enabled-fields that reference this one.
    $tax_fields = \Drupal::entityTypeManager()
      ->getStorage('field_config')
      ->loadByProperties(array('field_type' => 'entity_reference', 'entity_type' => 'node'));
    if (empty($tax_fields)) {
      return;
    }
    foreach ($tax_fields as $tax_field) {
      if (!$settings = $tax_field->getThirdPartySettings('abt')) {
        continue;
      }
      if ($settings['user_field'] != $field->getName()) {
        continue;
      }
      $items[] = $tax_field->id();
    }
    if (!empty($items)) {
      $form['entity_updates']['abt'] = [
        '#theme' => 'item_list',
        '#title' => t('Access By Term'),
        '#items' => $items,
      ];
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function abt_field_config_delete(FieldConfig $field_config) {
  if ($field_config->getType() !== 'entity_reference' || $field_config->getSetting('target_type') !== 'taxonomy_term' ||
    $field_config->getTargetEntityTypeId() !== ' user') {
    return;
  }
  // Find all abt fields that use this user field for access,
  // and remove their node access settings.
  $tax_fields = \Drupal::entityTypeManager()
    ->getStorage('field_config')
    ->loadByProperties(array('field_type' => 'entity_reference', 'entity_type' => 'node'));
  /** @var FieldConfig $tax_field */
  foreach ($tax_fields as $tax_field) {
    if ($tax_field->getThirdPartySetting('abt', 'user_field') == $field_config->getName()) {
      $setting_keys = array('abt_enable_view_control', 'abt_enable_update_control', 'abt_enable_delete_control', 'user_field');
      foreach ($setting_keys as $key) {
        $tax_field->unsetThirdPartySetting('abt', $key);
      }
      $tax_field->save();
      node_access_needs_rebuild(1);
    }
  }
}
