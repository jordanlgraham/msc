diff --git a/docroot/modules/contrib/paragraphs/paragraphs.install b/docroot/modules/contrib/paragraphs/paragraphs.install
index 927c7350a..f3883769d 100644
--- a/docroot/modules/contrib/paragraphs/paragraphs.install
+++ b/docroot/modules/contrib/paragraphs/paragraphs.install
@@ -91,7 +91,6 @@ function paragraphs_update_8004() {
     }
   }
 
-
   // Delete the storage definition if it was defined before.
   $storage_definition = $entity_definition_update_manager->getFieldStorageDefinition($field_name, 'paragraph');
   if ($storage_definition) {
@@ -220,6 +219,17 @@ function paragraphs_update_8012() {
 function paragraphs_update_8013() {
   $definition_update_manager = \Drupal::entityDefinitionUpdateManager();
   $entity_type = $definition_update_manager->getEntityType('paragraph');
+
+  // Update the revision metadata keys to remove revision uid which is removed
+  // in 8017 and 8021.
+  if ($metadata_keys = $entity_type->get('revision_metadata_keys')) {
+    if (is_array($metadata_keys) && isset($metadata_keys['revision_user'])) {
+      unset($metadata_keys['revision_user']);
+      $metadata_keys['revision_default'] = 'revision_default';
+      $entity_type->set('revision_metadata_keys', $metadata_keys);
+    }
+  }
+
   $keys = $entity_type->getKeys();
   $keys['published'] = 'status';
   $entity_type->set('entity_keys', $keys);
@@ -256,3 +266,201 @@ function paragraphs_update_8015() {
     }
   }
 }
+
+/**
+ * Remove the uid and revision_uid fields.
+ */
+function paragraphs_update_8016() {
+  $database = \Drupal::database();
+
+  $spec = array(
+    'type' => 'varchar',
+    'description' => "Revision UID",
+    'length' => 20,
+    'not null' => FALSE,
+  );
+
+  $schema = $database->schema();
+
+  if (!$schema->fieldExists('paragraphs_item_field_data', 'revision_uid')) {
+    $schema->addField('paragraphs_item_field_data', 'revision_uid', $spec);
+  }
+
+  if (!$schema->fieldExists('paragraphs_item_revision_field_data', 'revision_uid')) {
+    $schema->addField('paragraphs_item_revision_field_data', 'revision_uid', $spec);
+  }
+
+  $tables_fields = [
+    'paragraphs_item_revision' => 'revision_uid',
+    'paragraphs_item_field_data' => 'uid',
+    'paragraphs_item_revision_field_data' => 'uid',
+  ];
+
+  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
+
+  foreach ($tables_fields as $table => $field) {
+    if ($database->schema()->fieldExists($table, $field)) {
+      $database->update($table)
+        ->fields([$field => NULL])
+        ->execute();
+    }
+  }
+
+  foreach (array_unique($tables_fields) as $table => $field) {
+    $storage_definition = $entity_definition_update_manager->getFieldStorageDefinition($field, 'paragraph');
+    if ($storage_definition) {
+      $entity_definition_update_manager->uninstallFieldStorageDefinition($storage_definition);
+    }
+  }
+}
+
+/**
+* Moved function content to paragraphs_update_8023().
+* see https://www.drupal.org/project/paragraphs/issues/2833935#comment-13471948
+ */
+function paragraphs_update_8017() {
+}
+
+/**
+ * Make the parent fields revisionable.
+ */
+function paragraphs_update_8018(&$sandbox) {
+  $database = \Drupal::database();
+  // Initialize some variables during the first pass through.
+  if (!isset($sandbox['total'])) {
+    // Add the parent fields to the revision data table.
+    foreach (['parent_id', 'parent_type', 'parent_field_name'] as $field_name) {
+      $column_schema = [
+        'type' => 'varchar_ascii',
+        'length' => $field_name == 'parent_id' ? 255 : 32,
+        'binary' => FALSE,
+        'not null' => FALSE,
+      ];
+      // Create fields if they don't already exist.
+      if (!$database->schema()->fieldExists('paragraphs_item_revision_field_data', $field_name)) {
+        $database->schema()
+          ->addField('paragraphs_item_revision_field_data', $field_name, $column_schema);
+      }
+    }
+
+    // Get all paragraphs to update.
+    $paragraphs = \Drupal::database()->select('paragraphs_item_field_data', 'p')
+      ->countQuery()
+      ->execute()
+      ->fetchField(0);
+    $sandbox['total'] = $paragraphs;
+    $sandbox['current'] = 0;
+  }
+
+  // Do not continue if no paragraphs are found.
+  if (empty($sandbox['total'])) {
+    $sandbox['#finished'] = 1;
+    return t('No Paragraphs to be processed.');
+  }
+
+  $paragraphs_per_batch = 50;
+
+  $query = $database->select('paragraphs_item_field_data', 'p');
+  $query->fields('p', ['id', 'parent_id', 'parent_type', 'parent_field_name']);
+  $query->range($sandbox['current'], $paragraphs_per_batch);
+  $result = $query->execute();
+
+  foreach ($result as $row) {
+    $database->update('paragraphs_item_revision_field_data')
+      ->fields([
+        'parent_id' => $row->parent_id,
+        'parent_type' => $row->parent_type,
+        'parent_field_name' => $row->parent_field_name,
+      ])
+      ->condition('id', $row->id)
+      ->execute();
+    $sandbox['current']++;
+  }
+  $sandbox['#finished'] = ($sandbox['current'] / $sandbox['total']);
+  return t('@count Paragraphs processed.', ['@count' => $sandbox['current']]);
+}
+
+/**
+ * Update the field storage definitions of the parent fields.
+ */
+function paragraphs_update_8019() {
+  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
+  $definition_update_manager = \Drupal::entityDefinitionUpdateManager();
+  $last_installed_schema = \Drupal::service('entity.last_installed_schema.repository');
+  foreach (['parent_id', 'parent_type', 'parent_field_name'] as $field_name) {
+    $column_schema = [
+      'type' => 'varchar_ascii',
+      'length' => $field_name == 'parent_id' ? 255 : 32,
+      'binary' => FALSE,
+      'not null' => FALSE,
+    ];
+    // Update the field storage repository.
+    $storage_definition = $definition_update_manager->getFieldStorageDefinition($field_name, 'paragraph');
+    $storage_definition->setRevisionable(TRUE);
+    $last_installed_schema->setLastInstalledFieldStorageDefinition($storage_definition);
+
+    // Update the stored field schema.
+    // @todo: There has to be a better way to do this.
+    $key = 'paragraph.field_schema_data.' . $field_name;
+    $field_schema = \Drupal::keyValue('entity.storage_schema.sql')->get($key);
+    $field_schema['paragraphs_item_revision_field_data']['fields'][$field_name] = $column_schema;
+    \Drupal::keyValue('entity.storage_schema.sql')->set($key, $field_schema);
+  }
+}
+
+/**
+ * Remove the base field overrides for uid & revision_uid.
+ */
+function paragraphs_update_8020() {
+  $config_factory = \Drupal::configFactory();
+  $names = $config_factory->listAll('core.base_field_override.paragraph.');
+  foreach ($names as $name) {
+    $config = $config_factory->getEditable($name);
+    if (in_array($config->get('field_name'), ['uid', 'revision_uid'])) {
+      $config->delete();
+    }
+  }
+}
+
+/**
+ * Update the revision metadata keys to remove revision uid (fixes 8017).
+ */
+function paragraphs_update_8021() {
+  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
+  $entity_type = $entity_definition_update_manager->getEntityType('paragraph');
+  if ($metadata_keys = $entity_type->get('revision_metadata_keys')) {
+    if (is_array($metadata_keys) && isset($metadata_keys['revision_user'])) {
+      unset($metadata_keys['revision_user']);
+      $metadata_keys['revision_default'] = 'revision_default';
+      $entity_type->set('revision_metadata_keys', $metadata_keys);
+      $entity_definition_update_manager->updateEntityType($entity_type);
+    }
+  }
+}
+
+/**
+ * Ensure that the parent indexes are added to the revision data table.
+ */
+function paragraphs_update_8022() {
+  $manager = \Drupal::entityDefinitionUpdateManager();
+
+  // Regenerate entity type indexes.
+  $manager->updateEntityType($manager->getEntityType('paragraph'));
+}
+
+
+/**
+ * Update the revision metadata keys to remove revision uid.
+ */
+function paragraphs_update_8023() {
+  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
+  $entity_type = $entity_definition_update_manager->getEntityType('paragraph');
+  if ($metadata_keys = $entity_type->get('revision_metadata_keys')) {
+    if (is_array($metadata_keys) && isset($metadata_keys['revision_user'])) {
+      unset($metadata_keys['revision_user']);
+      $metadata_keys['revision_default'] = 'revision_default';
+      $entity_type->set('revision_metadata_keys', $metadata_keys);
+      $entity_definition_update_manager->updateEntityType($entity_type);
+    }
+  }
+}
